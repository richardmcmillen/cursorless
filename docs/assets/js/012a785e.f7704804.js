"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[867],{3905:function(e,t,r){r.d(t,{Zo:function(){return c},kt:function(){return u}});var n=r(67294);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,i=function(e,t){if(null==e)return{};var r,n,i={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var l=n.createContext({}),d=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},c=function(e){var t=d(e.components);return n.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var r=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=d(r),u=i,f=p["".concat(l,".").concat(u)]||p[u]||m[u]||a;return r?n.createElement(f,o(o({ref:t},c),{},{components:r})):n.createElement(f,o({ref:t},c))}));function u(e,t){var r=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=r.length,o=new Array(a);o[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var d=2;d<a;d++)o[d]=r[d];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}p.displayName="MDXCreateElement"},16902:function(e,t,r){r.r(t),r.d(t,{assets:function(){return c},contentTitle:function(){return l},default:function(){return u},frontMatter:function(){return s},metadata:function(){return d},toc:function(){return m}});var n=r(87462),i=r(63366),a=(r(67294),r(3905)),o=["components"],s={id:"processTargets_modifiers_surroundingPair_generateUnmatchedDelimiters",title:"Module: processTargets/modifiers/surroundingPair/generateUnmatchedDelimiters",sidebar_label:"processTargets/modifiers/surroundingPair/generateUnmatchedDelimiters",sidebar_position:0,custom_edit_url:null},l=void 0,d={unversionedId:"contributing/api/modules/processTargets_modifiers_surroundingPair_generateUnmatchedDelimiters",id:"contributing/api/modules/processTargets_modifiers_surroundingPair_generateUnmatchedDelimiters",title:"Module: processTargets/modifiers/surroundingPair/generateUnmatchedDelimiters",description:"Functions",source:"@site/../docs/contributing/api/modules/processTargets_modifiers_surroundingPair_generateUnmatchedDelimiters.md",sourceDirName:"contributing/api/modules",slug:"/contributing/api/modules/processTargets_modifiers_surroundingPair_generateUnmatchedDelimiters",permalink:"/docs/contributing/api/modules/processTargets_modifiers_surroundingPair_generateUnmatchedDelimiters",editUrl:null,tags:[],version:"current",sidebarPosition:0,frontMatter:{id:"processTargets_modifiers_surroundingPair_generateUnmatchedDelimiters",title:"Module: processTargets/modifiers/surroundingPair/generateUnmatchedDelimiters",sidebar_label:"processTargets/modifiers/surroundingPair/generateUnmatchedDelimiters",sidebar_position:0,custom_edit_url:null},sidebar:"contributing",previous:{title:"processTargets/modifiers/surroundingPair/findSurroundingPairTextBased",permalink:"/docs/contributing/api/modules/processTargets_modifiers_surroundingPair_findSurroundingPairTextBased"},next:{title:"processTargets/modifiers/surroundingPair/getIndividualDelimiters",permalink:"/docs/contributing/api/modules/processTargets_modifiers_surroundingPair_getIndividualDelimiters"}},c={},m=[{value:"Functions",id:"functions",level:2},{value:"findUnmatchedDelimiter",id:"findunmatcheddelimiter",level:3},{value:"Parameters",id:"parameters",level:4},{value:"Returns",id:"returns",level:4},{value:"Defined in",id:"defined-in",level:4},{value:"generateUnmatchedDelimiters",id:"generateunmatcheddelimiters",level:3},{value:"Parameters",id:"parameters-1",level:4},{value:"Returns",id:"returns-1",level:4},{value:"Defined in",id:"defined-in-1",level:4}],p={toc:m};function u(e){var t=e.components,r=(0,i.Z)(e,o);return(0,a.kt)("wrapper",(0,n.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"functions"},"Functions"),(0,a.kt)("h3",{id:"findunmatcheddelimiter"},"findUnmatchedDelimiter"),(0,a.kt)("p",null,"\u25b8 ",(0,a.kt)("strong",{parentName:"p"},"findUnmatchedDelimiter"),"(",(0,a.kt)("inlineCode",{parentName:"p"},"delimiterOccurrences"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"initialIndex"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"acceptableDelimiters"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"lookForward"),"): ",(0,a.kt)("a",{parentName:"p",href:"/docs/contributing/api/interfaces/processTargets_modifiers_surroundingPair_types.DelimiterOccurrence"},(0,a.kt)("inlineCode",{parentName:"a"},"DelimiterOccurrence"))," ","|"," ",(0,a.kt)("inlineCode",{parentName:"p"},"null")),(0,a.kt)("p",null,"Finds the first instance of an unmatched delimiter in the given direction"),(0,a.kt)("p",null,"This function is a simplified version of generateUnmatchedDelimiters, so look\nthere for details of the algorithm"),(0,a.kt)("h4",{id:"parameters"},"Parameters"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,a.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,a.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"left"},(0,a.kt)("inlineCode",{parentName:"td"},"delimiterOccurrences")),(0,a.kt)("td",{parentName:"tr",align:"left"},(0,a.kt)("a",{parentName:"td",href:"/docs/contributing/api/interfaces/processTargets_modifiers_surroundingPair_types.PossibleDelimiterOccurrence"},(0,a.kt)("inlineCode",{parentName:"a"},"PossibleDelimiterOccurrence")),"[]"),(0,a.kt)("td",{parentName:"tr",align:"left"},"A list of delimiter occurrences.  Expected to be sorted by offsets")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"left"},(0,a.kt)("inlineCode",{parentName:"td"},"initialIndex")),(0,a.kt)("td",{parentName:"tr",align:"left"},(0,a.kt)("inlineCode",{parentName:"td"},"number")),(0,a.kt)("td",{parentName:"tr",align:"left"},"The index of the delimiter to start from")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"left"},(0,a.kt)("inlineCode",{parentName:"td"},"acceptableDelimiters")),(0,a.kt)("td",{parentName:"tr",align:"left"},(0,a.kt)("a",{parentName:"td",href:"/docs/contributing/api/modules/typings_Types#simplesurroundingpairname"},(0,a.kt)("inlineCode",{parentName:"a"},"SimpleSurroundingPairName")),"[]"),(0,a.kt)("td",{parentName:"tr",align:"left"},"A list of names of acceptable delimiters to look for")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"left"},(0,a.kt)("inlineCode",{parentName:"td"},"lookForward")),(0,a.kt)("td",{parentName:"tr",align:"left"},(0,a.kt)("inlineCode",{parentName:"td"},"boolean")),(0,a.kt)("td",{parentName:"tr",align:"left"},"Whether to scan forwards or backwards")))),(0,a.kt)("h4",{id:"returns"},"Returns"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"/docs/contributing/api/interfaces/processTargets_modifiers_surroundingPair_types.DelimiterOccurrence"},(0,a.kt)("inlineCode",{parentName:"a"},"DelimiterOccurrence"))," ","|"," ",(0,a.kt)("inlineCode",{parentName:"p"},"null")),(0,a.kt)("p",null,"The first acceptable unmatched delimiter, if one is found otherwise null"),(0,a.kt)("h4",{id:"defined-in"},"Defined in"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/cursorless-dev/cursorless/blob/358cf95/src/processTargets/modifiers/surroundingPair/generateUnmatchedDelimiters.ts#L22"},"src/processTargets/modifiers/surroundingPair/generateUnmatchedDelimiters.ts:22")),(0,a.kt)("hr",null),(0,a.kt)("h3",{id:"generateunmatcheddelimiters"},"generateUnmatchedDelimiters"),(0,a.kt)("p",null,"\u25b8 ",(0,a.kt)("strong",{parentName:"p"},"generateUnmatchedDelimiters"),"(",(0,a.kt)("inlineCode",{parentName:"p"},"delimiterOccurrences"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"initialIndex"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"getCurrentAcceptableDelimiters"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"lookForward"),"): ",(0,a.kt)("a",{parentName:"p",href:"/docs/contributing/api/interfaces/core_updateSelections_RangeUpdater.internal.Generator"},(0,a.kt)("inlineCode",{parentName:"a"},"Generator")),"<",(0,a.kt)("a",{parentName:"p",href:"/docs/contributing/api/interfaces/processTargets_modifiers_surroundingPair_types.DelimiterOccurrence"},(0,a.kt)("inlineCode",{parentName:"a"},"DelimiterOccurrence")),", ",(0,a.kt)("inlineCode",{parentName:"p"},"void"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"never"),">"),(0,a.kt)("p",null,"This function is the heart of our surrounding pair algorithm.  It scans in\none direction (either forwards or backwards) through a list of delimiters,\nyielding each unmatched delimiter that it finds."),(0,a.kt)("p",null,"The algorithm proceeds by keeping a map from delimiter names to counts. Every\ntime it sees an instance of an opening or closing delimiter of the given\ntype, it will either increment or decrement the counter for the given\ndelimiter, depending which direction we're scanning."),(0,a.kt)("p",null,"If the count for any delimiter drops to -1, we yield it because it means it\nis unmatched."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"yields"))," Occurrences of unmatched delimiters"),(0,a.kt)("h4",{id:"parameters-1"},"Parameters"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,a.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,a.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"left"},(0,a.kt)("inlineCode",{parentName:"td"},"delimiterOccurrences")),(0,a.kt)("td",{parentName:"tr",align:"left"},(0,a.kt)("a",{parentName:"td",href:"/docs/contributing/api/interfaces/processTargets_modifiers_surroundingPair_types.PossibleDelimiterOccurrence"},(0,a.kt)("inlineCode",{parentName:"a"},"PossibleDelimiterOccurrence")),"[]"),(0,a.kt)("td",{parentName:"tr",align:"left"},"A list of delimiter occurrences.  Expected to be sorted by offsets")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"left"},(0,a.kt)("inlineCode",{parentName:"td"},"initialIndex")),(0,a.kt)("td",{parentName:"tr",align:"left"},(0,a.kt)("inlineCode",{parentName:"td"},"number")),(0,a.kt)("td",{parentName:"tr",align:"left"},"The index of the delimiter to start from")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"left"},(0,a.kt)("inlineCode",{parentName:"td"},"getCurrentAcceptableDelimiters")),(0,a.kt)("td",{parentName:"tr",align:"left"},"() => ",(0,a.kt)("a",{parentName:"td",href:"/docs/contributing/api/modules/typings_Types#simplesurroundingpairname"},(0,a.kt)("inlineCode",{parentName:"a"},"SimpleSurroundingPairName")),"[]"),(0,a.kt)("td",{parentName:"tr",align:"left"},"A function that returns a list of names of acceptable delimiters to look for.  We expect that this list might change every time we yield, depending on the outcome of the scan in the other direction")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"left"},(0,a.kt)("inlineCode",{parentName:"td"},"lookForward")),(0,a.kt)("td",{parentName:"tr",align:"left"},(0,a.kt)("inlineCode",{parentName:"td"},"boolean")),(0,a.kt)("td",{parentName:"tr",align:"left"},"Whether to scan forwards or backwards")))),(0,a.kt)("h4",{id:"returns-1"},"Returns"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"/docs/contributing/api/interfaces/core_updateSelections_RangeUpdater.internal.Generator"},(0,a.kt)("inlineCode",{parentName:"a"},"Generator")),"<",(0,a.kt)("a",{parentName:"p",href:"/docs/contributing/api/interfaces/processTargets_modifiers_surroundingPair_types.DelimiterOccurrence"},(0,a.kt)("inlineCode",{parentName:"a"},"DelimiterOccurrence")),", ",(0,a.kt)("inlineCode",{parentName:"p"},"void"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"never"),">"),(0,a.kt)("h4",{id:"defined-in-1"},"Defined in"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/cursorless-dev/cursorless/blob/358cf95/src/processTargets/modifiers/surroundingPair/generateUnmatchedDelimiters.ts#L61"},"src/processTargets/modifiers/surroundingPair/generateUnmatchedDelimiters.ts:61")))}u.isMDXComponent=!0}}]);